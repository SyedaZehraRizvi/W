-- Create customers table
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    full_name VARCHAR(100) NOT NULL,
    phone VARCHAR(15),
    city VARCHAR(50),
    email VARCHAR(100) UNIQUE NOT NULL
);

-- Create categories table
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(50) NOT NULL UNIQUE
);

-- Create products table
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL UNIQUE,
    category_id INT NOT NULL,
    unit_price DECIMAL(10, 2) NOT NULL CHECK (unit_price > 0),
    FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE RESTRICT
);

-- Create orders table
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL DEFAULT CURRENT_DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);

-- Create order_items table
CREATE TABLE order_items (
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL CHECK (quantity > 0),
    PRIMARY KEY (order_id, product_id),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(product_id) ON DELETE RESTRICT
);

-- Create payments table
CREATE TABLE payments (
    payment_id SERIAL PRIMARY KEY,
    order_id INT NOT NULL,
    amount DECIMAL(10, 2) NOT NULL CHECK (amount > 0),
    payment_date DATE NOT NULL DEFAULT CURRENT_DATE,
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE
);

-- Insert into categories
INSERT INTO categories (category_name) VALUES
('Electronics'),
('Groceries');

-- Insert into products (assumed prices for demo)
INSERT INTO products (product_name, category_id, unit_price) VALUES
('Laptop', 1, 50000.00),
('Headphones', 1, 5000.00),
('Rice 5kg', 2, 2000.00),
('Cooking Oil 1L', 2, 1500.00),
('Keyboard', 1, 3000.00);

-- Insert into customers
INSERT INTO customers (full_name, phone, city, email) VALUES
('Aarav Sharma', '9876543210', 'Delhi', 'aarav.sharma@example.com'),
('Priya Patel', '8765432109', 'Mumbai', 'priya.patel@example.com'),
('Saanvi Kumar', '7654321098', 'Bangalore', 'saanvi.kumar@example.com');

-- Insert into orders
INSERT INTO orders (customer_id, order_date) VALUES
(1, '2025-09-01'),
(2, '2025-09-02'),
(3, '2025-09-03');

-- Insert into order_items
INSERT INTO order_items (order_id, product_id, quantity) VALUES
(1, 1, 1), -- Aarav: 1 Laptop
(1, 2, 2), -- Aarav: 2 Headphones
(2, 3, 3), -- Priya: 3 Rice 5kg
(2, 4, 2), -- Priya: 2 Cooking Oil 1L
(3, 2, 1); -- Saanvi: 1 Headphones

-- Insert into payments
INSERT INTO payments (order_id, amount, payment_date) VALUES
(1, 60000.00, '2025-09-01'), -- Aarav: Laptop + 2 Headphones
(2, 9000.00, '2025-09-02'),  -- Priya: 3 Rice + 2 Cooking Oil
(3, 5000.00, '2025-09-03');  -- Saanvi: 1 Headphones

UPDATE products
SET unit_price = unit_price * 1.20
WHERE product_name = 'Headphones';

SELECT product_name, unit_price FROM products WHERE product_name = 'Headphones';
-- Output: Headphones, 6000.00

DELETE FROM products
WHERE product_name = 'Keyboard';

SELECT * FROM products WHERE product_name = 'Keyboard';
-- Output: (no rows)

SELECT p.product_name, p.unit_price
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE c.category_name = 'Groceries' AND p.unit_price < 5000;


SELECT full_name
FROM customers
WHERE full_name LIKE '%aa%';


SELECT 
    c.category_name,
    COALESCE(SUM(oi.quantity), 0) AS total_qty,
    COALESCE(SUM(oi.quantity * p.unit_price), 0) AS total_sales
FROM categories c
LEFT JOIN products p ON c.category_id = p.category_id
LEFT JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY c.category_name;


SELECT 
    c.category_name,
    SUM(oi.quantity * p.unit_price) AS total_sales
FROM categories c
JOIN products p ON c.category_id = p.category_id
JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY c.category_name
HAVING SUM(oi.quantity * p.unit_price) > 20000;

SELECT 
    o.order_id,
    o.order_date,
    c.full_name AS customer,
    COUNT(oi.product_id) AS item_count,
    SUM(oi.quantity * p.unit_price) AS total
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
GROUP BY o.order_id, o.order_date, c.full_name;

SELECT p.product_name
FROM products p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
WHERE oi.product_id IS NULL;

WITH avg_order_total AS (
    SELECT AVG(oi.quantity * p.unit_price) AS avg_total
    FROM order_items oi
    JOIN products p ON oi.product_id = p.product_id
)
SELECT 
    c.full_name,
    SUM(oi.quantity * p.unit_price) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
GROUP BY c.full_name
HAVING SUM(oi.quantity * p.unit_price) > (SELECT avg_total FROM avg_order_total);


SELECT 
    p.product_name,
    p.unit_price,
    c.category_name
FROM products p
JOIN categories c ON p.category_id = c.category_id
WHERE p.unit_price > (
    SELECT AVG(p2.unit_price)
    FROM products p2
    WHERE p2.category_id = p.category_id
);


a) Enumerate Entities, Keys, Relationships
Entities and Keys:

customers:

Primary Key: customer_id
Attributes: full_name, phone, city, email


categories:

Primary Key: category_id
Attributes: category_name


products:

Primary Key: product_id
Foreign Key: category_id (references categories)
Attributes: product_name, unit_price


orders:

Primary Key: order_id
Foreign Key: customer_id (references customers)
Attributes: order_date


order_items:

Composite Primary Key: (order_id, product_id)
Foreign Keys: order_id (references orders), product_id (references products)
Attributes: quantity


payments:

Primary Key: payment_id
Foreign Key: order_id (references orders)
Attributes: amount, payment_date



Relationships:

customers ↔ orders: One-to-Many (one customer can have multiple orders).
categories ↔ products: One-to-Many (one category can have multiple products).
orders ↔ order_items: One-to-Many (one order can have multiple items).
products ↔ order_items: One-to-Many (one product can appear in multiple order items).
orders ↔ payments: One-to-Many (one order can have multiple payments).

ERD Description (text-based, as no image generation):

customers → connected to orders via customer_id.
categories → connected to products via category_id.
orders → connected to order_items via order_id.
products → connected to order_items via product_id.
orders → connected to payments via order_id.

b) Prove 1NF
First Normal Form (1NF) requires:

All attributes are atomic (no multi-valued attributes or repeating groups).
Each table has a primary key.

Proof:

All tables (customers, categories, products, orders, order_items, payments) have atomic attributes (e.g., full_name is a single string, not a list).
No repeating groups (e.g., order_items uses a separate row for each product in an order, not a list within a column).
Each table has a primary key:

customers: customer_id
categories: category_id
products: product_id
orders: order_id
order_items: (order_id, product_id)
payments: payment_id


All tables satisfy 1NF.

c) Prove 2NF with order_items(order_id, product_id)
Second Normal Form (2NF) requires:

Table is in 1NF.
No partial dependency (non-key attributes depend on the entire composite key, not a subset).

Proof for order_items:

1NF: Already proven (atomic attributes, composite primary key: order_id, product_id).
Attributes: order_id, product_id, quantity.
Dependencies:

quantity depends on both order_id and product_id (e.g., the quantity of a product is specific to a particular order).
There are no non-key attributes that depend on only order_id or only product_id.


No partial dependency exists, as quantity requires the full composite key (order_id, product_id).
Thus, order_items satisfies 2NF.